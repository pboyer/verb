<!DOCTYPE html>
<html>

<head>
  <title>Curve Closest Point</title>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three/build/three.module.js",
        "three/addons/": "https://unpkg.com/three/examples/jsm/",
        "verb": "https://unpkg.com/verb-nurbs@3.0.2/build/js/verb.es.js",
        "web-worker": "https://unpkg.com/web-worker@1.3.0/browser.js"
      }
    }
  </script>
  <style>
    body { margin: 0 }
    #title { font-size: 40px; position: absolute; top: 20px; left: 20px; color: white; }
  </style>
</head>

<body>
  <div id="viewer">
    <div id="title"></div>
  </div>

<script type="module" id="MODELING">

import * as THREE from 'three'
import * as VERB from 'verb'

const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 )

camera.position.z = 5

const renderer = new THREE.WebGLRenderer()
renderer.setSize( window.innerWidth, window.innerHeight )
renderer.setAnimationLoop( animate )

const vieweElement = document.getElementById("viewer");
vieweElement.appendChild( renderer.domElement );

const title = document.getElementById("title");
title.innerHTML += document.title;

let meshs = []

function animate() {
  if (meshs.length) {
    meshs.forEach(( mesh ) => {
      mesh.rotation.x += 0.001
      mesh.rotation.y += 0.001
    })
  }

  renderer.render( scene, camera )
}

const flatten = ( arr ) => arr.reduce(( acc, val ) => Array.isArray( val ) ? acc.concat( flatten( val ) ) : acc.concat( val ), [])

function tessellateCurve( curve ) {
  const points = curve.tessellate()

  const coords = new Float32Array( flatten(points) )

  const geometry = new THREE.BufferGeometry()

  geometry.setAttribute( 'position', new THREE.BufferAttribute( coords, 3, false ) )

  geometry.scale( 0.25, 0.25, 0.25 )

  return geometry
}

function addCurveToScene(curve, material) {
  material = material || new THREE.LineBasicMaterial( { linewidth: 2, color: 0xdcdcdc } )

  const line = new THREE.Line( curve, material )

  meshs.push( line )
  scene.add( line )
}

// render the curve
const pts = [
  [ 0,  0, -5],
  [10,  0,  0],
  [10, 10, -5],
  [ 0, 10,  5],
  [ 5,  5,  0],
]
const interpCurve = VERB.default.geom.NurbsCurve.byPoints( pts, 3 )

const interpCurve3 = tessellateCurve( interpCurve )

addCurveToScene( interpCurve3 )

// render lines between points in space and closest points on the curve
const cpMaterial = new THREE.LineBasicMaterial( { linewidth: 1, color: 0x0000aa } )

const orbitpts = []
let w = 0
for (let i = -10; i < 20; i += 4){
    for (let j = -10; j < 20; j += 4){
        for (let k = -10; k < 20; k += 4){
            const p0 = [i, j, k ]

            orbitpts.push( p0 )

            const cp = interpCurve.closestPoint( p0 )

            const cpLine = new VERB.default.geom.Line( cp, p0 )
            addCurveToScene( tessellateCurve( cpLine ), cpMaterial )

            w++
        }
    }
}

</script>

</body>

</html>
