<!DOCTYPE html>
<html>
<head>
    <title>Surface Bezier Subdivision</title>

    <script src="../build/js/verb.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/verbToThreeConversion.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/codemirror.js"></script>
    <script src="js/javascript.js"></script>
    <script src="js/threeBasic.js"></script>

    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" href="css/codemirror.css">
    <link rel="stylesheet" href="css/example.css">
    <link rel="stylesheet" href="css/colorforth.css">
</head>
<body>

<div id="button">Show/Hide Code</div>
<div id="viewer" class="col">
    <div id="title"></div>
</div>
<div id="code-container" class="col scroll-y"></div>

</body>
<script id="script">
	setupScene();

    function asVector3(pts){
        return pts.map(function(x){
            return new THREE.Vector3(x[0],x[1],x[2]);
        });
    }

    function asGeometry(threePts){
        var geometry = new THREE.Geometry();
        geometry.vertices.push.apply( geometry.vertices, threePts );
        return geometry;
    }

    function tessellateSurface(srf, a, b) {

        var tess = verb.eval.Tess.rationalSurfaceNaive( srf, a, b );

        var geometry = new THREE.Geometry();
        var threePts = asVector3( tess.points );

        geometry.vertices.push.apply( geometry.vertices, threePts );

        var threeFaces = tess.faces.map(function(faceIndices){

            var normals = faceIndices.map(function(x){
                var vn = tess.normals[x];
                return new THREE.Vector3( vn[0], vn[1], vn[2] );
            });

            return new THREE.Face3(faceIndices[0],faceIndices[1],faceIndices[2], normals);
        });

        geometry.faces.push.apply(geometry.faces, threeFaces);
        return geometry;
    }

    function getThreeMesh( tess ) {

        var geometry = new THREE.Geometry();
        var threePts = asVector3( tess.points );

        geometry.vertices.push.apply( geometry.vertices, threePts );

        var threeFaces = tess.faces.map(function(faceIndices){
            return new THREE.Face3(faceIndices[0],faceIndices[1],faceIndices[2]);
        });

        geometry.faces.push.apply(geometry.faces, threeFaces);

        geometry.faceVertexUvs[0] = [];

        tess.faces.forEach(function(f){
            geometry.faceVertexUvs[0].push([
                new THREE.Vector2( tess.uvs[f[0]][0], tess.uvs[f[0]][1] ),
                new THREE.Vector2( tess.uvs[f[1]][0], tess.uvs[f[1]][1] ),
                new THREE.Vector2( tess.uvs[f[2]][0], tess.uvs[f[2]][1] ),
            ]);
        });

        geometry.computeFaceNormals();
        geometry.computeVertexNormals();

        return geometry;
    }

    var degree = 3
        , knotsV = [0, 0, 0, 0, 0.333, 0.666, 1, 1, 1, 1]
        , knotsU = [0, 0, 0, 0, 0.5, 1, 1, 1, 1]

        , controlPoints = [
                    [ [0, 0, 0],  [10, 0, 0],     [20, 0, 0],     [30, 0, 0] ,    [40, 0, 0],     [50, 0, 0] ],
                    [ [0, -10, 0],  [10, -10, 0],  [20, -10, 0],  [30, -10, 0] ,  [40, -10, 0],   [50, -10, 0]    ],
                    [ [0, -20, 0],  [10, -20, 0],  [20, -20, 0],  [30, -20, 0] ,  [40, -20, 0],  [50, -20, 0]    ],
                    [ [0, -30, 0],  [10, -30, 0],   [20, -30, 0], [30, -30, 0] ,  [40, -30, 0],   [50, -30, 0]     ],
                    [ [0, -40, 0],  [10, -40, 0],   [20, -40, 0],   [30, -40, 0] ,  [40, -40, 0], [50, -40, 0]     ] ]
        , surface = new verb.core.NurbsSurfaceData( degree, degree, knotsU, knotsV, controlPoints );


    var getSurface11 = () => {

        var degreeU = 3
            , degreeV = 3
            , knotsU = [0, 0, 0, 0, 1, 1, 1, 1]
            , knotsV =  [0, 0, 0, 0, 1, 1, 1, 1]
            , pts = [     [ [0, 0, 0],    [10, 0, 0],     [20, 0, 0],     [30, 0, 0]      ],
                                    [ [0, -10, 0],  [10, -10, 5],   [20, -10, 0],   [30, -10, 0]    ],
                                    [ [0, -20, 0],  [10, -20, 0],   [20, -20, 0],   [30, -20, 0]    ],
                                    [ [0, -30, 0],  [10, -30, 0],   [20, -30, 0],   [30, -30, 0]    ] ]
			, wts = [   [ 1, 1, 1, 1],
						[ 1, 1, 1, 1],
						[ 1, 1, 1, 1],
						[ 1, 1, 1, 1],
						[ 1, 1, 1, 1],
						[ 1, 1, 1, 1] ]
            , bezier = new verb.core.NurbsSurfaceData( degreeU, degreeV, knotsU, knotsV, verb.eval.Eval.homogenize2d(pts, wts) );

        return bezier;
    };

    function getBezier(){

        var degree = 3
            , knots = [0, 0, 0, 0, 1, 1, 1, 1]
            , pts = [   [ [0, 0, 0],  [10, 0, 0],     [20, 0, 0], [30, 0, 0] ],
                        [ [0, -10, 0],  [10, -10, 0],  [20, -10, 0], [30, -10, 0]   ],
                        [ [0, -20, 0],  [10, -20, 0],  [20, -20, 0], [30, -20, 0]  ],
                        [ [0, -30, 0],  [10, -30, 0],   [20, -30, 0], [30, -30, 0]     ]  ]
            , wts = [   [ 1, 1, 1, 1 ],
                        [ 1, 1, 1, 1 ],
                        [ 1, 1, 1, 1 ],
                        [ 1, 1, 1, 1 ] ];

        return new verb.core.NurbsSurfaceData( degree, degree, knots, knots, verb.eval.Eval.homogenize2d(pts, wts)  );
    }

    var getSurface23 = () => {
        var degree = 3
            , knotsV = [0, 0, 0, 0, 1, 2, 3, 3, 3, 3]
            , knotsU = [0, 0, 0, 0, 1, 2, 2, 2, 2]
            , pts = [ [ [0, 0, 12],    [10, 0, 0],     [20, 0, 0],     [30, 0, 0],    [40, 0, 0],     [50, 0, 0] ],
                        [ [0, -10, 0],  [10, -10, 0],  [20, -10, 0],  [30, -10, 0],  [40, -10, 0],   [50, -10, 0]    ],
                        [ [0, -20, 0],  [10, -20, 0],  [20, -20, 0],  [30, -20, 0],  [40, -20, 0],  [50, -20, 0]    ],
                        [ [0, -30, 0],  [10, -30, 0],   [20, -30, 0], [30, -30, 0],  [40, -30, 0],   [50, -30, 0]     ],
                        [ [0, -40, 0],  [10, -40, 0],   [20, -40, 0],   [30, -40, 0],  [40, -40, 0], [50, -40, -12]     ] ]
			, wts = [   [ 1, 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1, 1] ]
            , surface23 = new verb.core.NurbsSurfaceData( degree, degree, knotsU, knotsV, verb.eval.Eval.homogenize2d(pts, wts) );

        return surface23;
    };

	var getSurface23Deg2Curved = () => {
		var degree = 2
			, knotsV = [0, 0, 0, 0.333, 0.666, 1, 1, 1]
			, knotsU = [0, 0, 0, 0.5, 1, 1, 1]
			, pts = [ [ [0, 0, 0],    [10, 0, 0],     [20, 0, 0],     [30, 0, 0],    [40, 0, 0] ],
						[ [0, -10, 0],  [10, -10, 0],  [20, -10, 0],  [30, -10, 0],  [40, -10, 0]   ],
						[ [0, -20, 0],  [10, -20, 0],  [20, -20, 0],  [30, -20, 0],  [40, -20, 0]    ],
						[ [0, -30, 0],  [10, -30, 0],   [20, -30, 0], [30, -30, 0],  [40, -30, 0]     ] ]
			, wts = [   [ 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1],
						[ 1, 1, 1, 1, 1] ]
			, surface23 = new verb.core.NurbsSurfaceData( degree, degree, knotsU, knotsV, verb.eval.Eval.homogenize2d(pts, wts) );

		return surface23;
	};


    surface = getSurface23Deg2Curved();

    var tol = 1;

    var l = verb.eval.Tess.rationalBezierSurfaceStepLength( surface, tol );
    var res = verb.eval.Modify.decomposeSurfaceIntoBeziers( surface );

    for (var i = 0; i < res.length; i++){
        for (var j = 0; j < res[i].length; j++){
            var color = '#'+Math.floor(Math.random()*16777215).toString(16);
            var mat = new THREE.MeshBasicMaterial( { color: color, side: THREE.DoubleSide, wireframe: true });

            var srf = res[i][j];
            var mesh = verb.eval.Tess.rationalSurfaceAdaptiveSample( srf, tol );
            addMeshToScene( getThreeMesh( mesh ), mat );
        }
    }

	renderScene();
</script>

<script src="js/example.js"></script>

</html>