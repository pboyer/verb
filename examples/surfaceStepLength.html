<!DOCTYPE html>
<html>
<head>
    <title>Surface step length</title>

    <script src="../build/js/verb.js"></script>
    <script src="js/three.min.js"></script>
    <script src="js/verbToThreeConversion.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/codemirror.js"></script>
    <script src="js/javascript.js"></script>
    <script src="js/threeBasic.js"></script>

    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

    <link rel="stylesheet" href="css/codemirror.css">
    <link rel="stylesheet" href="css/example.css">
    <link rel="stylesheet" href="css/colorforth.css">
</head>
<body>

<div id="button">Show/Hide Code</div>
<div id="viewer" class="col">
    <div id="title"></div>
</div>
<div id="code-container" class="col scroll-y"></div>

</body>
<script id="script">

	setupScene();

    function asVector3(pts){
        return pts.map(function(x){
            return new THREE.Vector3(x[0],x[1],x[2]);
        });
    }

    function asGeometry(threePts){
        var geometry = new THREE.Geometry();
        geometry.vertices.push.apply( geometry.vertices, threePts );
        return geometry;
    }

    function tessellateSurface(srf, a, b) {

        var tess = verb.eval.Tess.rationalSurfaceNaive( srf, a, b );

        var geometry = new THREE.Geometry();
        var threePts = asVector3( tess.points );

        geometry.vertices.push.apply( geometry.vertices, threePts );

        var threeFaces = tess.faces.map(function(faceIndices){
            var normals = faceIndices.map(function(x){
                var vn = tess.normals[x];
                return new THREE.Vector3( vn[0], vn[1], vn[2] );
            });

            return new THREE.Face3(faceIndices[0],faceIndices[1],faceIndices[2], normals);
        });

        geometry.faces.push.apply(geometry.faces, threeFaces);
        return geometry;
    }

    function getComplexSurface(){

        var degree = 3
            , knots = [0, 0, 0, 0, 1, 1, 1, 1]
            , pts = [   [ [0, 0, 0],  [10, 0, 0],     [20, 0, 0], [30, 0, 0] ],
                        [ [0, -10, 0],  [10, -10, 0],  [20, -10, 0], [30, -10, 0]   ],
                        [ [0, -20, 0],  [10, -20, 0],  [20, -20, 0], [30, -20, 0]  ],
                        [ [0, -30, 10],  [10, -30, 10],   [20, -30, 10], [30, -30, 10]     ]  ]
            , wts = [   [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1],
                        [ 1, 1, 1, 1, 1, 1] ];

        pts = verb.eval.Eval.homogenize2d(pts, wts);

        return {
            degreeU : degree,
            degreeV : degree,
            knotsU : knots,
            knotsV : knots,
            controlPoints : pts
        };
    }

    var tol = 0.1;
    var srf = getComplexSurface();
	var l = verb.eval.Tess.rationalBezierSurfaceStepLength( srf, tol );

    var mat = new THREE.MeshBasicMaterial( { color: 0xffffff, side: THREE.DoubleSide, wireframe: true });

    addMeshToScene( tessellateSurface( srf, Math.ceil( 1 / l.item0 ), Math.ceil( 1 / l.item1) ), mat );

    var bs = new verb.geom.NurbsSurface( srf );

    addMeshToScene( bs.toThreeGeometry() );

	var pts = [ [35, -35, 0], [35, -35 + tol, 0 ] ];
	var tolcrv = verb.geom.NurbsCurve.byPoints( pts, 1 );
    addCurveToScene( tolcrv.toThreeGeometry() );

	renderScene();

</script>

<script src="js/example.js"></script>

</html>